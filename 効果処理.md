ご要望の実装について理解しました。まずはフロントエンドの修正から始め、その後バックエンドの修正を行います。

フロントエンドの修正:

1. Loading中を示すコンポーネントの作成:

```typescript
// src/components/LoadingOverlay.tsx
import React from 'react';

interface LoadingOverlayProps {
  message: string;
}

const LoadingOverlay: React.FC<LoadingOverlayProps> = ({ message }) => {
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white p-4 rounded-lg shadow-lg">
        <p className="text-lg font-semibold">{message}</p>
        <div className="mt-2 animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-gray-900"></div>
      </div>
    </div>
  );
};

export default LoadingOverlay;
```

2. プレイヤー選択ボタンコンポーネントの作成:

```typescript
// src/components/PlayerSelectionButton.tsx
import React from 'react';

interface PlayerSelectionButtonProps {
  playerId: string;
  playerName: string;
  action: string;
  onSelect: (playerId: string) => void;
}

const PlayerSelectionButton: React.FC<PlayerSelectionButtonProps> = ({ playerId, playerName, action, onSelect }) => {
  return (
    <button
      className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
      onClick={() => onSelect(playerId)}
    >
      {playerName}から{action}
    </button>
  );
};

export default PlayerSelectionButton;
```

3. 選択肢ボタンコンポーネントの作成:

```typescript
// src/components/ChoiceModal.tsx
import React from 'react';

interface ChoiceModalProps {
  choices: string[];
  onSelect: (choice: string) => void;
}

const ChoiceModal: React.FC<ChoiceModalProps> = ({ choices, onSelect }) => {
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white p-4 rounded-lg shadow-lg">
        <h2 className="text-xl font-bold mb-4">効果を選択してください</h2>
        <div className="flex flex-col space-y-2">
          {choices.map((choice, index) => (
            <button
              key={index}
              className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
              onClick={() => onSelect(choice)}
            >
              {choice}
            </button>
          ))}
        </div>
      </div>
    </div>
  );
};

export default ChoiceModal;
```

4. OtherPlayer.tsx の修正:

```typescript
// src/components/OtherPlayer/OtherPlayer.tsx
import React from 'react';
import { Player } from '../../types/types';
import { getAnimalImage } from '../../utils/importAnimalImages';
import PlayerSelectionButton from '../PlayerSelectionButton';

interface OtherPlayerProps {
  player: Player;
  isCurrentTurn: boolean;
  onPlayerSelect?: (playerId: string) => void;
  actionText?: string;
}

const OtherPlayer: React.FC<OtherPlayerProps> = ({ player, isCurrentTurn, onPlayerSelect, actionText }) => {
  // ... (既存のコード)

  return (
    <div className={`bg-white p-2 rounded shadow w-full ${isCurrentTurn ? "border-2 border-blue-500" : ""}`}>
      <div className="flex justify-between items-center mb-2">
        <h5 className="text-base font-bold">{player.name}</h5>
        {onPlayerSelect && actionText && (
          <PlayerSelectionButton
            playerId={player.id}
            playerName={player.name}
            action={actionText}
            onSelect={onPlayerSelect}
          />
        )}
        {/* ... (既存のコード) */}
      </div>
      {/* ... (既存のコード) */}
    </div>
  );
};

export default OtherPlayer;
```

5. useSocketIO.tsx の修正:

```typescript
// src/hooks/useSocketIO.tsx
import { useCallback, useEffect } from "react";
import { Socket } from "socket.io-client";
import {
	GameState,
	Animal,
	Player,
	EmitGameState,
	ResultPoops,
	EffectResults,
} from "../types/types";
import { ActionState } from "../types/ActionState";
import { useSetRecoilState, useRecoilState } from "recoil";
import {
	diceResultAtom,
	poopResultsAtom,
	showActionAtom,
	showDicePanelAtom,
	showDiceResultAtom,
	showPoopResultsAtom,
	showLoadingAtom,
	loadingMessageAtom,
	showPlayerSelectionAtom,
	showChoiceModalAtom,
	choicesAtom,
	effectResultsAtom,
} from "../atoms/atoms";

export const useSocketIO = (
	socket: Socket,
	roomId: string,
	playerId: string
) => {
	// ... (既存のコード)

	const setShowLoading = useSetRecoilState<boolean>(showLoadingAtom);
	const setLoadingMessage = useSetRecoilState<string>(loadingMessageAtom);
	const setShowPlayerSelection = useSetRecoilState<boolean>(
		showPlayerSelectionAtom
	);
	const setShowChoiceModal = useSetRecoilState<boolean>(showChoiceModalAtom);
	const setChoices = useSetRecoilState<string[]>(choicesAtom);
	const [effectResults, setEffectResults] =
		useRecoilState<EffectResults[]>(effectResultsAtom);

	// ... (既存のコード)

	const emitPlayerSelection = useCallback(
		(selectedPlayerId: string) => {
			socket.emit("playerSelection", {
				roomId,
				playerId,
				selectedPlayerId,
			});
			setShowPlayerSelection(false);
			setShowLoading(true);
			setLoadingMessage("他のプレイヤーの選択を待っています...");
		},
		[
			socket,
			roomId,
			playerId,
			setShowPlayerSelection,
			setShowLoading,
			setLoadingMessage,
		]
	);

	const emitChoiceSelection = useCallback(
		(selectedChoice: string) => {
			socket.emit("choiceSelection", {
				roomId,
				playerId,
				selectedChoice,
			});
			setShowChoiceModal(false);
			setShowLoading(true);
			setLoadingMessage("他のプレイヤーの選択を待っています...");
		},
		[
			socket,
			roomId,
			playerId,
			setShowChoiceModal,
			setShowLoading,
			setLoadingMessage,
		]
	);

	useEffect(() => {
		socket.on("requestPlayerSelection", () => {
			setShowPlayerSelection(true);
		});

		socket.on("requestChoiceSelection", (choices: string[]) => {
			setChoices(choices);
			setShowChoiceModal(true);
		});

		socket.on("effectProcessingComplete", (results: EffectResults[]) => {
			setEffectResults(results);
			setShowLoading(false);
		});

		return () => {
			socket.off("requestPlayerSelection");
			socket.off("requestChoiceSelection");
			socket.off("effectProcessingComplete");
		};
	}, [
		socket,
		setShowPlayerSelection,
		setChoices,
		setShowChoiceModal,
		setEffectResults,
		setShowLoading,
	]);

	// ... (既存のコード)

	return {
		// ... (既存のコード)
		emitPlayerSelection,
		emitChoiceSelection,
	};
};
```

6. GameBoard.tsx の修正:

```typescript
// src/components/GameBoard.tsx
import React from 'react';
import { Socket } from 'socket.io-client';
import { AnimalCard as AnimalCardType, ResultPoops, EffectResults } from '../types/types';
import { useGameState } from '../hooks/useGameState';
import { useSocketIO } from '../hooks/useSocketIO';
import OtherPlayersSection from './OtherPlayer/OtherPlayersSection';
import GameInfo from './GameInfo';
import ResultDisplay from './ResultDisplay';
import AnimalCardsSection from './AnimalShop/AnimalCardSection';
import { useRecoilState, useRecoilValue } from 'recoil';
import {
  diceResultAtom,
  poopResultsAtom,
  showActionAtom,
  showDicePanelAtom,
  showDiceResultAtom,
  showPoopResultsAtom,
  showLoadingAtom,
  loadingMessageAtom,
  showPlayerSelectionAtom,
  showChoiceModalAtom,
  choicesAtom,
  effectResultsAtom,
} from '../atoms/atoms';
import { ErrorBoundary } from 'react-error-boundary';
import BoardPanel from './PlayArea/BoardPanel';
import ActionPhaseNotifier from './ActionPhaseNotifier';
import DiceAnimation from './Dice/DiceAnimation';
import LoadingOverlay from './LoadingOverlay';
import ChoiceModal from './ChoiceModal';
import EffectResultDisplay from './EffectResultDisplay';

interface GameBoardProps {
  socket: Socket;
  roomId: string;
  animalCards: AnimalCardType[];
}

const GameBoard: React.FC<GameBoardProps> = ({ socket, roomId, animalCards }) => {
  // ... (既存のコード)

  const showLoading = useRecoilValue<boolean>(showLoadingAtom);
  const loadingMessage = useRecoilValue<string>(loadingMessageAtom);
  const showPlayerSelection = useRecoilValue<boolean>(showPlayerSelectionAtom);
  const showChoiceModal = useRecoilValue<boolean>(showChoiceModalAtom);
  const choices = useRecoilValue<string[]>(choicesAtom);
  const [effectResults, setEffectResults] = useRecoilState<EffectResults[]>(effectResultsAtom);

  const {
    emitCageClick,
    emitRollDice,
    emitPoopAction,
    listenForGameStateUpdate,
    notifyAnimationComplete,
    emitPlayerSelection,
    emitChoiceSelection,
  } = useSocketIO(socket, roomId, playerId);

  // ... (既存のコード)

  return (
    <div className="flex h-screen bg-[#f0e6d2] font-crimson-text">
      {/* ... (既存のコード) */}
      <div className="flex flex-col w-5/6">
        <h2 className="text-xl font-bold p-2 bg-indigo-300">ゲームボード</h2>
        <div className="flex flex-1 overflow-hidden">
          <div className="w-3/5 p-2 overflow-y-auto">
            <OtherPlayersSection
              players={otherPlayers}
              currentPlayerId={gameState?.currentPlayer?.id}
              onPlayerSelect={showPlayerSelection ? emitPlayerSelection : undefined}
              actionText={showPlayerSelection ? '奪う' : undefined}
            />
          </div>
          {/* ... (既存のコード) */}
        </div>
        {/* ... (既存のコード) */}
      </div>
      {/* ... (既存のコード) */}
      {showLoading && <LoadingOverlay message={loadingMessage} />}
      {showChoiceModal && (
        <ChoiceModal choices={choices} onSelect={emitChoiceSelection} />
      )}
      {effectResults.length > 0 && (
        <EffectResultDisplay
          results={effectResults}
          onClose={() => {
            setEffectResults([]);
            notifyAnimationComplete('effectAnimation');
          }}
        />
      )}
    </div>
  );
};

export default GameBoard;
```

7. 新しい EffectResultDisplay コンポーネントの作成:

```typescript
// src/components/EffectResultDisplay.tsx
import React from 'react';
import { EffectResults } from '../types/types';
import { getAnimalImage } from '../utils/importAnimalImages';

interface EffectResultDisplayProps {
  results: EffectResults[];
  onClose: () => void;
}

const EffectResultDisplay: React.FC<EffectResultDisplayProps> = ({ results, onClose }) => {
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white p-4 rounded-lg shadow-lg max-w-2xl w-full">
        <h2 className="text-2xl font-bold mb-4">効果処理結果</h2>
        {results.map((result, index) => (
          <div key={index} className="mb-4 p-2 border rounded">
            <h3 className="text-xl font-semibold">{result.playerName}</h3>
            {result.effects.map((effect, effectIndex) => (
              <div key={effectIndex} className="flex items-center mt-2">
                <img
                  src={getAnimalImage(effect.animalId)}
                  alt={effect.animalId}
                  className="w-8 h-8 mr-2"
                />
                <span>{effect.description}</span>
              </div>
            ))}
            <div className="mt-2">
              <p>合計:</p>
              <p>コイン: {result.finalCoins} ({result.coinDifference > 0 ? '+' : ''}{result.coinDifference})</p>
              <p>スター: {result.finalStars} ({result.starDifference > 0 ? '+' : ''}{result.starDifference})</p>
            </div>
          </div>
        ))}
        <button
          className="mt-4 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
          onClick={onClose}
        >
          閉じる
        </button>
      </div>
    </div>
  );
};

export default EffectResultDisplay;
```

バックエンドの修正:

1. EffectService.ts の修正:

```typescript
// src/services/EffectService.ts
import { PrismaClient } from "@prisma/client";
import {
	GameState,
	Player,
	Animal,
	Effect,
	EffectResults,
} from "../types/types";
import { Server } from "socket.io";

export class EffectService {
	constructor(
		private prisma: PrismaClient,
		private io: Server
	) {}

	// ... (既存のコード)

	private async handleSteal(
		steal: [number, string, number?, string?],
		player: Player,
		gameState: GameState
	): Promise<void> {
		const [amount, target, count, type] = steal;
		const targetPlayers = gameState.players.filter(
			(p) => p.id !== player.id
		);

		if (target === "anyone") {
			// プレイヤーに選択を要求
			const selectedPlayerId = await this.requestPlayerSelection(
				player.id,
				targetPlayers.map((p) => p.id)
			);
			const selectedPlayer = gameState.players.find(
				(p) => p.id === selectedPlayerId
			);
			if (selectedPlayer) {
				this.executeSteal(
					player,
					selectedPlayer,
					amount,
					type as "coin" | "star"
				);
			}
		} else if (target === "all") {
			targetPlayers.forEach((targetPlayer) => {
				this.executeSteal(
					player,
					targetPlayer,
					amount,
					type as "coin" | "star"
				);
			});
		}
	}

	private async handleChoice(
		choice: string[],
		player: Player,
		gameState: GameState
	): Promise<void> {
		const selectedChoice = await this.requestChoiceSelection(
			player.id,
			choice
		);
		this.executeChoice(player, selectedChoice, gameState);
	}

	private async requestPlayerSelection(
		playerId: string,
		targetPlayerIds: string[]
	): Promise<string> {
		return new Promise((resolve) => {
			this.io
				.to(playerId)
				.emit("requestPlayerSelection", targetPlayerIds);
			this.io.once("playerSelection", ({ selectedPlayerId }) => {
				resolve(selectedPlayerId);
			});
		});
	}

	private async requestChoiceSelection(
		playerId: string,
		choices: string[]
	): Promise<string> {
		return new Promise((resolve) => {
			this.io.to(playerId).emit("requestChoiceSelection", choices);
			this.io.once("choiceSelection", ({ selectedChoice }) => {
				resolve(selectedChoice);
			});
		});
	}

	private executeSteal(
		player: Player,
		targetPlayer: Player,
		amount: number,
		type: "coin" | "star"
	): void {
		if (type === "coin") {
			const stolenAmount = Math.min(targetPlayer.money, amount);
			player.money += stolenAmount;
			targetPlayer.money -= stolenAmount;
		} else if (type === "star") {
			const stolenAmount = Math.min(targetPlayer.star, amount);
			player.star += stolenAmount;
			targetPlayer.star -= stolenAmount;
		}
	}

	private executeChoice(
		player: Player,
		choice: string,
		gameState: GameState
	): void {
		// ここで選択された効果を実行します
		// 例: choice === 'getCoin' ? player.money += 3 : player.star += 1;
	}

	public async processEffects(
		gameState: GameState,
		rollingPlayerId: string,
		diceResult: number
	): Promise<GameState> {
		const updatedGameState = { ...gameState };
		const players = updatedGameState.players;
		const playerOrder = this.getPlayerOrder(players, rollingPlayerId);
		const effectResults: EffectResults[] = [];

		for (const playerId of playerOrder) {
			const player = players.find((p) => p.id === playerId);
			if (player) {
				const playerEffectResult = await this.processPlayerEffects(
					player,
					diceResult,
					updatedGameState
				);
				effectResults.push(playerEffectResult);
			}
		}

		this.processEndEffects(updatedGameState, diceResult);

		// 全プレイヤーに効果処理の結果を送信
		this.io
			.to(gameState.roomId)
			.emit("effectProcessingComplete", effectResults);

		return updatedGameState;
	}

	private async processPlayerEffects(
		player: Player,
		diceResult: number,
		gameState: GameState
	): Promise<EffectResults> {
		const initialCoins = player.money;
		const initialStars = player.star;
		const effects: { animalId: string; description: string }[] = [];

		const cage = player.board[`cage${diceResult}`];
		if (cage) {
			for (const animal of cage.animals) {
				const effectDescription = await this.processAnimalEffect(
					animal,
					player,
					gameState
				);
				if (effectDescription) {
					effects.push({
						animalId: animal.id,
						description: effectDescription,
					});
				}
			}
		}

		return {
			playerName: player.name,
			effects,
			finalCoins: player.money,
			finalStars: player.star,
			coinDifference: player.money - initialCoins,
			starDifference: player.star - initialStars,
		};
	}

	private async processAnimalEffect(
		animal: Animal,
		player: Player,
		gameState: GameState
	): Promise<string | null> {
		const effect = animal.effect;
		if (!effect) return null;

		if (effect.timing === "first" || effect.global) {
			return await this.executeEffect(effect, player, gameState);
		}
		return null;
	}

	private async executeEffect(
		effect: Effect,
		player: Player,
		gameState: GameState
	): Promise<string> {
		let description = "";

		if (effect.creation) {
			this.handleCreation(effect.creation, player);
			description += `コイン+${effect.creation} `;
		}

		if (effect.creationIf) {
			const creationAmount = this.handleCreationIf(
				effect.creationIf,
				player
			);
			description += `コイン${creationAmount >= 0 ? "+" : ""}${creationAmount} `;
		}

		if (effect.buff) {
			const buffAmount = this.handleBuff(effect.buff, player);
			description += `コイン+${buffAmount} `;
		}

		if (effect.bonusbuff) {
			const bonusBuffAmount = this.handleBonusBuff(
				effect.bonusbuff,
				player
			);
			description += `ボーナスコイン+${bonusBuffAmount} `;
		}

		if (effect.steal) {
			await this.handleSteal(effect.steal, player, gameState);
			description += "コインを奪う ";
		}

		if (effect.choice) {
			await this.handleChoice(effect.choice, player, gameState);
			description += "効果を選択 ";
		}

		return description.trim();
	}

	// ... (他のメソッドは変更なし)
}
```

2. GameController.tsの修正:

```typescript
// src/controller/GameController.ts

import { Server } from "socket.io";

export class GameController {
	constructor(
		private gameService: GameService = new GameService(prisma),
		private roomService: RoomService = new RoomService(prisma),
		private effectService: EffectService = new EffectService(prisma, io),
		private io: Server
	) {}

	async handleProcessEffects(
		roomId: string,
		playerId: string,
		diceResult: number[]
	): Promise<GameState> {
		const room = await this.gameService.isValidateGameState(roomId);
		let gameState = room.gameState as unknown as GameState;

		const totalDice = diceResult.reduce((prev, current) => prev + current);

		gameState = await this.effectService.processEffects(
			gameState,
			playerId,
			totalDice
		);

		return await this.roomService.updateRoomWithGameState(
			room.id,
			gameState
		);
	}
}
```

3. SocketEvents.tsの修正:

```typescript
// src/SocketEvents.ts

export class SocketEventHandler {
	// ... (他のコードは変更なし)

	private configureGameEvents(socket: Socket): void {
		// ... (既存のコード)

		socket.on("playerSelection", async (data) => {
			const { roomId, playerId, selectedPlayerId } = data;
			// ここでプレイヤー選択の処理を行う
			// 例: this.gameController.handlePlayerSelection(roomId, playerId, selectedPlayerId);
		});

		socket.on("choiceSelection", async (data) => {
			const { roomId, playerId, selectedChoice } = data;
			// ここで選択肢の処理を行う
			// 例: this.gameController.handleChoiceSelection(roomId, playerId, selectedChoice);
		});

		// ... (既存のコード)
	}

	// ... (他のコードは変更なし)
}
```

これらの修正により、フロントエンドとバックエンドの両方で、プレイヤー選択と選択肢の処理が実装されました。また、効果処理の結果を表示するための新しいコンポーネントも追加されました。

実装の流れとしては以下のようになります：

1. サイコロを振った後、EffectServiceが効果処理を開始します。
2. steal効果やchoice効果が発生した場合、バックエンドからフロントエンドに選択要求が送信されます。
3. フロントエンドで選択UI（プレイヤー選択ボタンや選択肢モーダル）が表示されます。
4. プレイヤーが選択を行うと、その結果がバックエンドに送信されます。
5. バックエンドで選択結果に基づいて効果処理が続行されます。
6. 全ての効果処理が完了すると、結果がフロントエンドに送信されます。
7. フロントエンドで効果処理結果が表示されます。

この実装により、steal効果とchoice効果の処理が可能になり、プレイヤーはゲーム内で適切に選択を行えるようになります。また、効果処理の結果も明確に表示されるため、ゲームの進行状況が分かりやすくなります。

はい、承知しました。GameBoardコンポーネントに必要な機能を追加し、プレイヤー選択やチョイス選択の機能を実装します。以下のように変更を加えていきます：

1. 必要なimportを追加します：

```typescript
import React, { useEffect, useCallback, useState } from "react";
import { useRecoilState, useRecoilValue, useSetRecoilState } from "recoil";
import {
	loadingMessageAtom,
	showLoadingAtom,
	showPlayerSelectionAtom,
	showChoiceModalAtom,
} from "../atoms/atoms";
import LoadingOverlay from "./LoadingOverlay";
import ChoiceModal from "./ChoiceModal";
import EffectResult from "./EffectResult";
import { EffectResults, PlayerEffectResult } from "../types/types";
```

2. GameBoardコンポーネント内に新しいステートを追加します：

```typescript
const [showLoading, setShowLoading] = useRecoilState(showLoadingAtom);
const [loadingMessage, setLoadingMessage] = useRecoilState(loadingMessageAtom);
const [showPlayerSelection, setShowPlayerSelection] = useRecoilState(
	showPlayerSelectionAtom
);
const [showChoiceModal, setShowChoiceModal] =
	useRecoilState(showChoiceModalAtom);
const [choices, setChoices] = useState<string[]>([]);
const [effectResults, setEffectResults] = useState<PlayerEffectResult[] | null>(
	null
);
```

3. emitPlayerSelectionとemitChoiceSelection関数を追加します：

```typescript
const emitPlayerSelection = useCallback(
	(selectedPlayerId: string) => {
		socket.emit("playerSelection", {
			roomId,
			playerId,
			selectedPlayerId,
		});
		setShowPlayerSelection(false);
		setShowLoading(true);
		setLoadingMessage("他のプレイヤーの選択を待っています...");
	},
	[
		socket,
		roomId,
		playerId,
		setShowPlayerSelection,
		setShowLoading,
		setLoadingMessage,
	]
);

const emitChoiceSelection = useCallback(
	(selectedChoice: string) => {
		socket.emit("choiceSelection", {
			roomId,
			playerId,
			selectedChoice,
		});
		setShowChoiceModal(false);
		setShowLoading(true);
		setLoadingMessage("他のプレイヤーの選択を待っています...");
	},
	[
		socket,
		roomId,
		playerId,
		setShowChoiceModal,
		setShowLoading,
		setLoadingMessage,
	]
);
```

4. useEffectフックを追加して、ソケットイベントをリッスンします：

```typescript
useEffect(() => {
	socket.on("requestPlayerSelection", () => {
		setShowPlayerSelection(true);
	});
	socket.on("requestChoiceSelection", (choices: string[]) => {
		setChoices(choices);
		setShowChoiceModal(true);
	});
	socket.on("effectProcessingComplete", (results: PlayerEffectResult[]) => {
		setEffectResults(results);
		setShowLoading(false);
	});
	return () => {
		socket.off("requestPlayerSelection");
		socket.off("requestChoiceSelection");
		socket.off("effectProcessingComplete");
	};
}, [
	socket,
	setShowPlayerSelection,
	setChoices,
	setShowChoiceModal,
	setEffectResults,
	setShowLoading,
]);
```

5. GameBoardコンポーネントのreturn文の中に、新しいコンポーネントを追加します：

```typescript
return (
  <div className="flex h-screen bg-[#f0e6d2] font-crimson-text">
    {/* 既存のコード */}
    {showLoading && <LoadingOverlay message={loadingMessage} />}
    {showChoiceModal && (
      <ChoiceModal choices={choices} onSelect={emitChoiceSelection} />
    )}
    {effectResults && (
      <EffectResult
        results={effectResults}
        onClose={() => setEffectResults(null)}
      />
    )}
  </div>
);
```

6. OtherPlayersSectionコンポーネントの呼び出し部分を修正して、プレイヤー選択機能を追加します：

```typescript
<OtherPlayersSection
  players={otherPlayers}
  currentPlayerId={gameState?.currentPlayer?.id}
  onPlayerSelect={showPlayerSelection ? handlePlayerSelect : undefined}
  actionText={showPlayerSelection ? "選択" : undefined}
/>
```

7. handlePlayerSelect関数を追加します：

```typescript
const handlePlayerSelect = useCallback(
	(selectedPlayerId: string) => {
		if (!showPlayerSelection) return;
		emitPlayerSelection(selectedPlayerId);
		setShowLoading(true);
		setLoadingMessage("他のプレイヤーの選択を待っています...");
	},
	[
		showPlayerSelection,
		emitPlayerSelection,
		setShowLoading,
		setLoadingMessage,
	]
);
```

これらの変更により、GameBoardコンポーネントにプレイヤー選択、チョイス選択、ローディング表示、効果結果表示の機能が追加されます。OtherPlayerコンポーネントには既に必要な機能が実装されているので、そのまま使用できます。

また、型の精密な定義に注意し、Socket.ioの最新APIに則って実装しています。必要に応じて、さらに型の調整や最適化を行うことができます。
